#!/usr/bin/python3
# -*- coding: utf-8 -*-
#
#    Copyright (C) 2024 by YOUR NAME HERE
#
#    This file is part of RoboComp
#
#    RoboComp is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    RoboComp is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with RoboComp.  If not, see <http://www.gnu.org/licenses/>.
#

##########################################################################
# AGENTE SOLO PARA EBO
# SI EBO NO ESTÁ ENCENDIDO, Y EL PC NO ESTA CONECTADO A EBO
# ESTE AGENTE NO FUNCIONARÁ
##########################################################################

from PySide2.QtCore import QTimer
from PySide2.QtWidgets import QApplication
from rich.console import Console
from genericworker import *
import interfaces as ifaces

sys.path.append('/opt/robocomp/lib')
console = Console(highlight=False)

from pydsr import *

# Imports de MeloTTS
import subprocess
import sys

try:
	from Queue import Queue
except ImportError:
	from queue import Queue

from PySide2.QtCore import QTimer
from PySide2.QtWidgets import QApplication
from genericworker import *
import time

# Nuevos imports
from melo.api import TTS
from pydub import AudioSegment
from pydub.playback import play
import threading
import os
import random

max_queue = 100
charsToAvoid = ["'", '"', '{', '}', '[', '<', '>', '(', ')', '&', '$', '|', '#']

# If RoboComp was compiled with Python bindings you can use InnerModel in Python
# import librobocomp_qmat
# import librobocomp_osgviewer
# import librobocomp_innermodel


class SpecificWorker(GenericWorker):
    """
    Processes text-to-speech (TTS) and speech recognition (ASR) tasks, managing
    node attributes and edge connections within a graph structure. It handles
    startup checks, audio generation, and playback, as well as updating and deleting
    nodes and edges.

    Attributes:
        Period (int): 2000 milliseconds (2 seconds). It appears to be used as a
            timer period for scheduling tasks.
        audioenviado (bool): Initialized as `False`. It appears to indicate whether
            audio has been sent or not, but its purpose and usage within the class
            are unclear.
        text_queue (Queue[max_queue]): Used for storing text messages that need
            to be processed by the `new_tts` method.
        device (str): Assigned the value `'cuda:0'`. This suggests that it refers
            to a device, possibly a GPU, with ID '0'.
        model (TTS): Initialized with a language ('ES' for Spanish) and device ('cuda:0').
        speaker_ids (Dict[str,int]): Used by the TTS (Text-To-Speech) model to
            identify speakers. It maps speaker names to corresponding IDs, allowing
            for specific voices or languages to be selected.
        speed (float): 1.0 by default. It seems to control the playback speed of
            audio generated by the Text-To-Speech (TTS) model, with higher values
            indicating faster playback and lower values indicating slower playback.
        agent_id (int): 5 by default, it seems to be used as a reference or
            identifier for the agent (maybe a robot or a software agent) that this
            worker represents.
        g (DSRGraph): Initialized with a value of DSRGraph(0, "pythonAgent",
            self.agent_id). This suggests that it represents a graph object used
            to manage nodes and edges in a directed graph.
        last_text (str): Loaded from a node named "TTS" within a graph object `g`.
            It stores the text to be spoken or generated by the TTS system.
        last_out (str|None): Stored in a node "LLM" of the graph g. It seems to
            hold the output of a language model.
        update_node_att (NoneNone,int,List[str]): Used to check if a node's
            attributes have been updated and update the last text and out_llama
            values accordingly. It also puts the new value in the text queue for
            further processing.
        startup_check (bool): Used for a startup check. When it's set to True, it
            will trigger a QTimer event after 200 milliseconds that will quit the
            application.
        timer (QTimer): Started in the `__init__` method with a period of
            `self.Period`. When the timer times out, it triggers the `compute` method.
        compute (bool|None): Called when a timer event occurs. It checks if there
            are any texts to say (i.e., not empty queue) and calls the `new_tts`
            method if so, otherwise does nothing.
        emotionalmotor_proxy (object): Not defined within this code. It seems to
            be a proxy for controlling the emotional motor of the worker, allowing
            methods such as expressing joy, anger, fear, or talking.

    """
    def __init__(self, proxy_map, startup_check=False):
        """
        Initializes an object by setting instance variables, connecting signals
        to methods, and starting a timer. It also checks for startup issues if
        required. The method sets up various attributes and proxies for a worker
        that performs tasks related to text-to-speech conversion.

        Args:
            proxy_map (Dict[str, object]): Passed to the superclass `super(SpecificWorker,
                self).__init__(proxy_map)`. It seems to be used for initialization
                purposes.
            startup_check (bool): Default set to False. It indicates whether a
                startup check should be performed when initializing the object.

        """
        super(SpecificWorker, self).__init__(proxy_map)
        self.Period = 2000

        #MeloTTS INITS
        self.audioenviado = False
        self.text_queue = Queue(max_queue)

        self.device = 'cuda:0'  # Usando la gráfica
        self.model = TTS(language='ES', device=self.device)
        self.speaker_ids = self.model.hps.data.spk2id
        self.speed = 1.0
        ###########################################
        # YOU MUST SET AN UNIQUE ID FOR THIS AGENT IN YOUR DEPLOYMENT. "_CHANGE_THIS_ID_" for a valid unique integer
        self.agent_id = 5
        self.g = DSRGraph(0, "pythonAgent", self.agent_id)


        # Se lee el nodo del grafo
        tts_node = self.g.get_node("TTS")

        # Se guardan los valores iniciales
        print("Cargando valores iniciales del atributo to_say")
        self.last_text = tts_node.attrs["to_say"].value

        # Comprobación de esta carga de valores iniciales del grafo
        if self.last_text == tts_node.attrs["to_say"].value:
            print("Valores iniciales cargados correctamente")
        else:
            print(
                "Valores iniciales error al cargar (Puede afectar al inicio del programa, pero no es un problema grave)")

        llm_node = self.g.get_node("LLM")
        print("Cargando valores iniciales del atributo out_llama")
        self.last_out = llm_node.attrs["out_llama"].value

        try:
            signals.connect(self.g, signals.UPDATE_NODE_ATTR, self.update_node_att)
            #signals.connect(self.g, signals.UPDATE_NODE, self.update_node)
            #signals.connect(self.g, signals.DELETE_NODE, self.delete_node)
            #signals.connect(self.g, signals.UPDATE_EDGE, self.update_edge)
            #signals.connect(self.g, signals.UPDATE_EDGE_ATTR, self.update_edge_att)
            #signals.connect(self.g, signals.DELETE_EDGE, self.delete_edge)
            #console.print("signals connected")
        except RuntimeError as e:
            print(e)

        if startup_check:
            self.startup_check()
        else:
            self.timer.timeout.connect(self.compute)
            self.timer.start(self.Period)

        self.emotionalmotor_proxy.expressJoy() # Pone a EBO contento al lanzar el agente, como de momento solo vamos a meter ASR, TTS y LLama que tenga buena cara.


    def __del__(self):
        """Destructor"""

    def setParams(self, params):
        # try:
        #	self.innermodel = InnerModel(params["InnerModelPath"])
        # except:
        #	traceback.print_exc()
        #	print("Error reading config params")
        """
        Sets parameters and returns a boolean value indicating success or failure.
        In its current form, it returns True regardless of any exceptions that may
        occur while setting the parameters, and does not provide error handling information.

        Args:
            params (Any): Expected to be set by the caller, possibly representing
                configuration or settings for the object on which this method is
                called.

        Returns:
            bool: True. It indicates that the operation has been completed
            successfully without any exceptions being raised.

        """
        return True


    # Función que contiene y ejecuta todo lo necesario para generar el audio TTS a partir del texto y reproducirlo. Con la nueva voz del TTS.
    def new_tts(self, text):
        # Función para dividir el texto en partes más pequeñas
        """
        Generates text-to-speech (TTS) audio for input text, splits it into smaller
        parts, and plays them while sending emotional feedback to a proxy. It also
        updates an ASR node in a graph.

        Args:
            text (str): Expected to be the text that needs to be converted into
                audio. The function breaks this text into smaller parts, generates
                audio for each part, and then plays it back.

        Returns:
            bool: False if there is no ASR node, otherwise it modifies an attribute
            of the ASR node and returns a value indicating success (True).

        """
        def split_text(text):
            """
            Splits a given text into multiple parts, each approximately 75 or 150
            characters long, depending on whether it is the first or subsequent
            part. It stops at the nearest punctuation mark (., !, ?) if no spaces
            are found within the limit.

            Args:
                text (str): Expected to be a string that contains text content,
                    which may include punctuation marks such as `.`, `!`, and `?`.

            Returns:
                List[str]: A list of strings, where each string represents a part
                of the input text, split based on sentence boundaries and a maximum
                length of either 75 or 150 characters for the first two parts, respectively.

            """
            parts = []
            start = 0
            end = 0
            while end < len(text):
                # Encontrar el final de la parte basado en las reglas especificadas
                if len(parts) == 0 or len(parts) == 1:
                    # Para la primera y segunda parte, encontrar el primer punto después de 75 caracteres
                    end = min(start + 75, len(text))
                    while end < len(text) and text[end] not in [".", "!", "?"]:
                        end += 1
                else:
                    # Para las siguientes partes, encontrar "." "!" o "?" después de 150 caracteres
                    end = min(start + 150, len(text))
                    while end < len(text) and text[end] not in [".", "!", "?"]:
                        end += 1

                # Agregar la parte al resultado
                parts.append(text[start:end + 1].strip())

                # Mover el inicio al siguiente punto de división
                start = end + 1 if end < len(text) else len(text)

            return parts

        # Función para generar audio y agregar las rutas de salida a la cola
        def generate_audio(queue):
            """
            Processes a list of text parts and generates corresponding audio files
            using a text-to-speech model. It iterates over the parts, converts
            each to an audio file, and adds the file path to a queue. Finally, it
            signals the end of processing by adding `None` to the queue.

            Args:
                queue (Queue): Used to put audio files into it after they are
                    generated, allowing them to be retrieved later for further
                    processing or playback.

            """
            for i, part in enumerate(text_parts):
                output_path = output_paths[i]
                self.model.tts_to_file(part, self.speaker_ids['ES'], output_path, speed=self.speed)
                queue.put(output_path)
            # Marcar el final de la cola
            queue.put(None)

        # Función para reproducir el audio en orden
        def play_audio(queue):
            """
            Retrieves audio files from a queue, plays them using the `AudioSegment`
            library and the `play` function, and indicates to an emotional motor
            proxy that talking is occurring during playback.

            Args:
                queue (Queue): Assumed to be a thread-safe queue, possibly implemented
                    using a multiprocessing queue or a thread-safe list. The
                    function gets tasks from this queue until it receives a null
                    task to exit.

            """
            while True:
                output_path = queue.get()
                if output_path is None:
                    break
                audio = AudioSegment.from_file(output_path)
                self.emotionalmotor_proxy.talking(True)
                play(audio)
                self.emotionalmotor_proxy.talking(False)
                queue.task_done()
                semaphore.release()

        # Obtener las partes del texto
        text_parts = split_text(text)

        # Ruta de salida
        output_paths = [f"es_{i}.wav" for i in range(len(text_parts))]
        # Cola para almacenar las rutas de salida de los archivos de audio generados
        output_queue = Queue()
        # Semáforo para sincronizar la generación y reproducción
        semaphore = threading.Semaphore(0)
        # Hilo para generar audio
        generate_thread = threading.Thread(target=generate_audio, args=(output_queue,))
        generate_thread.start()
        # Hilo para reproducir el audio
        play_thread = threading.Thread(target=play_audio, args=(output_queue,))
        play_thread.start()
        # Esperar a que todos los archivos de audio estén listos para reproducirse
        for _ in range(len(text_parts)):
            semaphore.acquire()
        # Esperar a que ambos hilos terminen
        generate_thread.join()
        play_thread.join()
        # Eliminar archivos temporales
        for output_path in output_paths:
            os.remove(output_path)
        
        ########################################################################
        # Modificar bool del ASR para que empiece a escuchar al terminar de hablar.
        asr_node = self.g.get_node("ASR")

        if asr_node is None:
            print("No ASR")
            return False
        else:
            asr_node.attrs["escuchando"] = Attribute(True, self.agent_id)
            print("Atributo modificado")
            self.g.update_node(asr_node)
        ########################################################################

    @QtCore.Slot()
    def compute(self):
        """
        Retrieves text from a queue when it is not empty, processes the text by
        calling the `new_tts` method, and returns True to indicate successful
        execution. If the queue is empty, the method does nothing.

        Returns:
            bool: `True`. This indicates that the operation was successful, and
            any output is not explicitly handled within this function.

        """
        if self.text_queue.empty():
            #print("Cola vacía")
            pass
        else:
            text_to_say = self.text_queue.get()
            self.new_tts(text_to_say)
            pass

        return True

    def startup_check(self):
        QTimer.singleShot(200, QApplication.instance().quit)




    ######################
    # From the RoboCompEmotionalMotor you can call this methods:
    # self.emotionalmotor_proxy.expressAnger(...)
    # self.emotionalmotor_proxy.expressDisgust(...)
    # self.emotionalmotor_proxy.expressFear(...)
    # self.emotionalmotor_proxy.expressJoy(...)
    # self.emotionalmotor_proxy.expressSadness(...)
    # self.emotionalmotor_proxy.expressSurprise(...)
    # self.emotionalmotor_proxy.isanybodythere(...)
    # self.emotionalmotor_proxy.listening(...)
    # self.emotionalmotor_proxy.pupposition(...)
    # self.emotionalmotor_proxy.talking(...)

    def actualizar_to_say(self, nuevo):
        """
        Updates the "to_say" attribute of a TTS (Text-To-Speech) node with a new
        value, if such a node exists, and then saves the updated node back to its
        original graph.

        Args:
            nuevo (str | bytes): Expected to be used as the value for the "to_say"
                attribute of the TTS node.

        Returns:
            bool: False if it cannot find a node named "TTS" or True otherwise,
            indicating whether the attribute "to_say" was successfully modified
            and the node updated.

        """
        tts_node = self.g.get_node("TTS")
        if tts_node is None:
            print("No TTS")
            return False
        else:
            tts_node.attrs["to_say"] = Attribute(nuevo, self.agent_id)
            print("Atributo modificado")
            self.g.update_node(tts_node)

    # =============== DSR SLOTS  ================
    # =============================================

    def update_node_att(self, id: int, attribute_names: [str]):
        """
        Updates attributes of nodes "Therapist", "LLM" and "TTS" based on their
        current values, updating internal state variables as needed, and logs
        messages to console when certain conditions are met.

        Args:
            id (int): Used to specify an identifier that presumably identifies the
                node for which attributes are being updated or retrieved.
            attribute_names ([str]): Expected to be a list of strings representing
                attribute names associated with the node identified by the given
                `id`.

        """
        ther_node = self.g.get_node("Therapist")
        if ther_node.attrs["automatic_mode"].value == True:
            llm_node = self.g.get_node("LLM")
            if llm_node.attrs["out_llama"].value != self.last_out and llm_node.attrs["out_llama"].value != "":
                self.last_out = llm_node.attrs["out_llama"].value
                self.actualizar_to_say(self.last_out)
            else:
                pass

            tts_node = self.g.get_node("TTS")
            if tts_node.attrs["to_say"].value != self.last_text and tts_node.attrs["to_say"].value != "":
                self.text_queue.put(tts_node.attrs["to_say"].value)
                self.last_text = tts_node.attrs["to_say"].value
                console.print(f"UPDATE NODE ATT: {id} {attribute_names}", style='green')
            else:
                pass
        else:
            pass


    def update_node(self, id: int, type: str):
        console.print(f"UPDATE NODE: {id} {type}", style='green')

    def delete_node(self, id: int):
        console.print(f"DELETE NODE:: {id} ", style='green')

    def update_edge(self, fr: int, to: int, type: str):

        """
        Updates an edge in a graph by specifying its source (from), destination
        (to), and type.

        Args:
            fr (int): Used as the starting point or origin node for an edge in a
                graph data structure.
            to (int): Used to specify the destination node or edge being updated.
            type (str): Used to specify the type of edge being updated between
                nodes `fr` and `to`.

        """
        console.print(f"UPDATE EDGE: {fr} to {type}", type, style='green')

    def update_edge_att(self, fr: int, to: int, type: str, attribute_names: [str]):
        console.print(f"UPDATE EDGE ATT: {fr} to {type} {attribute_names}", style='green')

    def delete_edge(self, fr: int, to: int, type: str):
        console.print(f"DELETE EDGE: {fr} to {type} {type}", style='green')
