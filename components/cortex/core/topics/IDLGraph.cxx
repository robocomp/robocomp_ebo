// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/*!
 * @file IDLGraph.cpp
 * This source file contains the implementation of the described types in the IDL file.
 *
 * This file was generated by the tool fastddsgen.
 */

#ifdef _WIN32
// Remove linker warning LNK4221 on Visual Studio
namespace {
char dummy;
}  // namespace
#endif  // _WIN32

#include <dsr/core/topics/IDLGraph.h>
#include <fastcdr/Cdr.h>


#include <fastcdr/exceptions/BadParamException.h>
using namespace eprosima::fastcdr::exception;

#include <utility>

namespace IDL {

Val::Val()
{
    m__d = 0;
}

Val::~Val()
{
}

Val::Val(
        const Val& x)
{
    m__d = x.m__d;

    switch (m__d)
    {
        case 0:
            m_str = x.m_str;
            break;


        case 1:
            m_dec = x.m_dec;
            break;


        case 2:
            m_fl = x.m_fl;
            break;


        case 3:
            m_float_vec = x.m_float_vec;
            break;


        case 4:
            m_bl = x.m_bl;
            break;


        case 5:
            m_byte_vec = x.m_byte_vec;
            break;


        case 6:
            m_uint = x.m_uint;
            break;


        case 7:
            m_u64 = x.m_u64;
            break;


        case 8:
            m_dob = x.m_dob;
            break;


        case 9:
            m_uint64_vec = x.m_uint64_vec;
            break;


        case 10:
            m_vec_float2 = x.m_vec_float2;
            break;


        case 11:
            m_vec_float3 = x.m_vec_float3;
            break;


        case 12:
            m_vec_float4 = x.m_vec_float4;
            break;


        case 13:
            m_vec_float6 = x.m_vec_float6;
            break;

        default:
            break;
    }
}

Val::Val(
        Val&& x) noexcept
{
    m__d = x.m__d;

    switch (m__d)
    {
        case 0:
            m_str = std::move(x.m_str);

            break;


        case 1:
            m_dec = x.m_dec;
            break;


        case 2:
            m_fl = x.m_fl;
            break;


        case 3:
            m_float_vec = std::move(x.m_float_vec);

            break;


        case 4:
            m_bl = x.m_bl;
            break;


        case 5:
            m_byte_vec = std::move(x.m_byte_vec);

            break;


        case 6:
            m_uint = x.m_uint;
            break;


        case 7:
            m_u64 = x.m_u64;
            break;


        case 8:
            m_dob = x.m_dob;
            break;


        case 9:
            m_uint64_vec = std::move(x.m_uint64_vec);

            break;


        case 10:
            m_vec_float2 = std::move(x.m_vec_float2);

            break;


        case 11:
            m_vec_float3 = std::move(x.m_vec_float3);

            break;


        case 12:
            m_vec_float4 = std::move(x.m_vec_float4);

            break;


        case 13:
            m_vec_float6 = std::move(x.m_vec_float6);

            break;

        default:
            break;
    }
}

Val& Val::operator =(
        const Val& x)
{
    m__d = x.m__d;

    switch (m__d)
    {
        case 0:
            m_str = x.m_str;
            break;


        case 1:
            m_dec = x.m_dec;
            break;


        case 2:
            m_fl = x.m_fl;
            break;


        case 3:
            m_float_vec = x.m_float_vec;
            break;


        case 4:
            m_bl = x.m_bl;
            break;


        case 5:
            m_byte_vec = x.m_byte_vec;
            break;


        case 6:
            m_uint = x.m_uint;
            break;


        case 7:
            m_u64 = x.m_u64;
            break;


        case 8:
            m_dob = x.m_dob;
            break;


        case 9:
            m_uint64_vec = x.m_uint64_vec;
            break;


        case 10:
            m_vec_float2 = x.m_vec_float2;
            break;


        case 11:
            m_vec_float3 = x.m_vec_float3;
            break;


        case 12:
            m_vec_float4 = x.m_vec_float4;
            break;


        case 13:
            m_vec_float6 = x.m_vec_float6;
            break;

        default:
            break;
    }

    return *this;
}

Val& Val::operator =(
        Val&& x) noexcept
{
    m__d = x.m__d;

    switch (m__d)
    {
        case 0:
            m_str = std::move(x.m_str);

            break;


        case 1:
            m_dec = x.m_dec;
            break;


        case 2:
            m_fl = x.m_fl;
            break;


        case 3:
            m_float_vec = std::move(x.m_float_vec);

            break;


        case 4:
            m_bl = x.m_bl;
            break;


        case 5:
            m_byte_vec = std::move(x.m_byte_vec);

            break;


        case 6:
            m_uint = x.m_uint;
            break;


        case 7:
            m_u64 = x.m_u64;
            break;


        case 8:
            m_dob = x.m_dob;
            break;


        case 9:
            m_uint64_vec = std::move(x.m_uint64_vec);

            break;


        case 10:
            m_vec_float2 = std::move(x.m_vec_float2);

            break;


        case 11:
            m_vec_float3 = std::move(x.m_vec_float3);

            break;


        case 12:
            m_vec_float4 = std::move(x.m_vec_float4);

            break;


        case 13:
            m_vec_float6 = std::move(x.m_vec_float6);

            break;

        default:
            break;
    }

    return *this;
}

bool Val::operator ==(
        const Val& x) const
{
    if (m__d != x.m__d)
    {
        return false;
    }

    switch (m__d)
    {
        case 0:
            return (m_str == x.m_str);
            break;


        case 1:
            return (m_dec == x.m_dec);
            break;


        case 2:
            return (m_fl == x.m_fl);
            break;


        case 3:
            return (m_float_vec == x.m_float_vec);
            break;


        case 4:
            return (m_bl == x.m_bl);
            break;


        case 5:
            return (m_byte_vec == x.m_byte_vec);
            break;


        case 6:
            return (m_uint == x.m_uint);
            break;


        case 7:
            return (m_u64 == x.m_u64);
            break;


        case 8:
            return (m_dob == x.m_dob);
            break;


        case 9:
            return (m_uint64_vec == x.m_uint64_vec);
            break;


        case 10:
            return (m_vec_float2 == x.m_vec_float2);
            break;


        case 11:
            return (m_vec_float3 == x.m_vec_float3);
            break;


        case 12:
            return (m_vec_float4 == x.m_vec_float4);
            break;


        case 13:
            return (m_vec_float6 == x.m_vec_float6);
            break;

        default:
            break;
    }
    return false;
}

bool Val::operator !=(
        const Val& x) const
{
    return !(*this == x);
}

void Val::_d(
        int32_t __d)
{
    bool b = false;

    switch (m__d)
    {
        case 0:
            switch (__d)
            {
                case 0:
                    b = true;
                    break;
                default:
                    break;
            }
            break;


        case 1:
            switch (__d)
            {
                case 1:
                    b = true;
                    break;
                default:
                    break;
            }
            break;


        case 2:
            switch (__d)
            {
                case 2:
                    b = true;
                    break;
                default:
                    break;
            }
            break;


        case 3:
            switch (__d)
            {
                case 3:
                    b = true;
                    break;
                default:
                    break;
            }
            break;


        case 4:
            switch (__d)
            {
                case 4:
                    b = true;
                    break;
                default:
                    break;
            }
            break;


        case 5:
            switch (__d)
            {
                case 5:
                    b = true;
                    break;
                default:
                    break;
            }
            break;


        case 6:
            switch (__d)
            {
                case 6:
                    b = true;
                    break;
                default:
                    break;
            }
            break;


        case 7:
            switch (__d)
            {
                case 7:
                    b = true;
                    break;
                default:
                    break;
            }
            break;


        case 8:
            switch (__d)
            {
                case 8:
                    b = true;
                    break;
                default:
                    break;
            }
            break;


        case 9:
            switch (__d)
            {
                case 9:
                    b = true;
                    break;
                default:
                    break;
            }
            break;


        case 10:
            switch (__d)
            {
                case 10:
                    b = true;
                    break;
                default:
                    break;
            }
            break;


        case 11:
            switch (__d)
            {
                case 11:
                    b = true;
                    break;
                default:
                    break;
            }
            break;


        case 12:
            switch (__d)
            {
                case 12:
                    b = true;
                    break;
                default:
                    break;
            }
            break;


        case 13:
            switch (__d)
            {
                case 13:
                    b = true;
                    break;
                default:
                    break;
            }
            break;

        default:
            break;
    }

    if (!b)
    {
        throw BadParamException("Discriminator doesn't correspond with the selected union member");
    }

    m__d = __d;
}

int32_t Val::_d() const
{
    return m__d;
}

int32_t& Val::_d()
{
    return m__d;
}

void Val::str(
        const std::string& _str)
{
    m_str = _str;
    m__d = 0;

}

void Val::str(
        std::string&& _str)
{
    m_str = std::move(_str);
    m__d = 0;

}

const std::string& Val::str() const
{
    bool b = false;

    switch (m__d)
    {
        case 0:
            b = true;
            break;
        default:
            break;
    }

    if (!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_str;
}

std::string& Val::str()
{
    bool b = false;

    switch (m__d)
    {
        case 0:
            b = true;
            break;
        default:
            break;
    }

    if (!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_str;
}


void Val::dec(
        int32_t _dec)
{
    m_dec = _dec;
    m__d = 1;

}

int32_t Val::dec() const
{
    bool b = false;

    switch (m__d)
    {
        case 1:
            b = true;
            break;
        default:
            break;
    }

    if (!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_dec;
}

int32_t& Val::dec()
{
    bool b = false;

    switch (m__d)
    {
        case 1:
            b = true;
            break;
        default:
            break;
    }

    if (!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_dec;
}


void Val::fl(
        float _fl)
{
    m_fl = _fl;
    m__d = 2;

}

float Val::fl() const
{
    bool b = false;

    switch (m__d)
    {
        case 2:
            b = true;
            break;
        default:
            break;
    }

    if (!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_fl;
}

float& Val::fl()
{
    bool b = false;

    switch (m__d)
    {
        case 2:
            b = true;
            break;
        default:
            break;
    }

    if (!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_fl;
}


void Val::float_vec(
        const std::vector<float>& _float_vec)
{
    m_float_vec = _float_vec;
    m__d = 3;

}

void Val::float_vec(
        std::vector<float>&& _float_vec)
{
    m_float_vec = std::move(_float_vec);
    m__d = 3;

}

const std::vector<float>& Val::float_vec() const
{
    bool b = false;

    switch (m__d)
    {
        case 3:
            b = true;
            break;
        default:
            break;
    }

    if (!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_float_vec;
}

std::vector<float>& Val::float_vec()
{
    bool b = false;

    switch (m__d)
    {
        case 3:
            b = true;
            break;
        default:
            break;
    }

    if (!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_float_vec;
}


void Val::bl(
        bool _bl)
{
    m_bl = _bl;
    m__d = 4;

}

bool Val::bl() const
{
    bool b = false;

    switch (m__d)
    {
        case 4:
            b = true;
            break;
        default:
            break;
    }

    if (!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_bl;
}

bool& Val::bl()
{
    bool b = false;

    switch (m__d)
    {
        case 4:
            b = true;
            break;
        default:
            break;
    }

    if (!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_bl;
}


void Val::byte_vec(
        const std::vector<uint8_t>& _byte_vec)
{
    m_byte_vec = _byte_vec;
    m__d = 5;

}

void Val::byte_vec(
        std::vector<uint8_t>&& _byte_vec)
{
    m_byte_vec = std::move(_byte_vec);
    m__d = 5;

}

const std::vector<uint8_t>& Val::byte_vec() const
{
    bool b = false;

    switch (m__d)
    {
        case 5:
            b = true;
            break;
        default:
            break;
    }

    if (!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_byte_vec;
}

std::vector<uint8_t>& Val::byte_vec()
{
    bool b = false;

    switch (m__d)
    {
        case 5:
            b = true;
            break;
        default:
            break;
    }

    if (!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_byte_vec;
}


void Val::uint(
        uint32_t _uint)
{
    m_uint = _uint;
    m__d = 6;

}

uint32_t Val::uint() const
{
    bool b = false;

    switch (m__d)
    {
        case 6:
            b = true;
            break;
        default:
            break;
    }

    if (!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_uint;
}

uint32_t& Val::uint()
{
    bool b = false;

    switch (m__d)
    {
        case 6:
            b = true;
            break;
        default:
            break;
    }

    if (!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_uint;
}


void Val::u64(
        uint64_t _u64)
{
    m_u64 = _u64;
    m__d = 7;

}

uint64_t Val::u64() const
{
    bool b = false;

    switch (m__d)
    {
        case 7:
            b = true;
            break;
        default:
            break;
    }

    if (!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_u64;
}

uint64_t& Val::u64()
{
    bool b = false;

    switch (m__d)
    {
        case 7:
            b = true;
            break;
        default:
            break;
    }

    if (!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_u64;
}


void Val::dob(
        double _dob)
{
    m_dob = _dob;
    m__d = 8;

}

double Val::dob() const
{
    bool b = false;

    switch (m__d)
    {
        case 8:
            b = true;
            break;
        default:
            break;
    }

    if (!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_dob;
}

double& Val::dob()
{
    bool b = false;

    switch (m__d)
    {
        case 8:
            b = true;
            break;
        default:
            break;
    }

    if (!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_dob;
}


void Val::uint64_vec(
        const std::vector<uint64_t>& _uint64_vec)
{
    m_uint64_vec = _uint64_vec;
    m__d = 9;

}

void Val::uint64_vec(
        std::vector<uint64_t>&& _uint64_vec)
{
    m_uint64_vec = std::move(_uint64_vec);
    m__d = 9;

}

const std::vector<uint64_t>& Val::uint64_vec() const
{
    bool b = false;

    switch (m__d)
    {
        case 9:
            b = true;
            break;
        default:
            break;
    }

    if (!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_uint64_vec;
}

std::vector<uint64_t>& Val::uint64_vec()
{
    bool b = false;

    switch (m__d)
    {
        case 9:
            b = true;
            break;
        default:
            break;
    }

    if (!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_uint64_vec;
}


void Val::vec_float2(
        const std::array<float, 2>& _vec_float2)
{
    m_vec_float2 = _vec_float2;
    m__d = 10;

}

void Val::vec_float2(
        std::array<float, 2>&& _vec_float2)
{
    m_vec_float2 = std::move(_vec_float2);
    m__d = 10;

}

const std::array<float, 2>& Val::vec_float2() const
{
    bool b = false;

    switch (m__d)
    {
        case 10:
            b = true;
            break;
        default:
            break;
    }

    if (!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_vec_float2;
}

std::array<float, 2>& Val::vec_float2()
{
    bool b = false;

    switch (m__d)
    {
        case 10:
            b = true;
            break;
        default:
            break;
    }

    if (!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_vec_float2;
}


void Val::vec_float3(
        const std::array<float, 3>& _vec_float3)
{
    m_vec_float3 = _vec_float3;
    m__d = 11;

}

void Val::vec_float3(
        std::array<float, 3>&& _vec_float3)
{
    m_vec_float3 = std::move(_vec_float3);
    m__d = 11;

}

const std::array<float, 3>& Val::vec_float3() const
{
    bool b = false;

    switch (m__d)
    {
        case 11:
            b = true;
            break;
        default:
            break;
    }

    if (!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_vec_float3;
}

std::array<float, 3>& Val::vec_float3()
{
    bool b = false;

    switch (m__d)
    {
        case 11:
            b = true;
            break;
        default:
            break;
    }

    if (!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_vec_float3;
}


void Val::vec_float4(
        const std::array<float, 4>& _vec_float4)
{
    m_vec_float4 = _vec_float4;
    m__d = 12;

}

void Val::vec_float4(
        std::array<float, 4>&& _vec_float4)
{
    m_vec_float4 = std::move(_vec_float4);
    m__d = 12;

}

const std::array<float, 4>& Val::vec_float4() const
{
    bool b = false;

    switch (m__d)
    {
        case 12:
            b = true;
            break;
        default:
            break;
    }

    if (!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_vec_float4;
}

std::array<float, 4>& Val::vec_float4()
{
    bool b = false;

    switch (m__d)
    {
        case 12:
            b = true;
            break;
        default:
            break;
    }

    if (!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_vec_float4;
}


void Val::vec_float6(
        const std::array<float, 6>& _vec_float6)
{
    m_vec_float6 = _vec_float6;
    m__d = 13;

}

void Val::vec_float6(
        std::array<float, 6>&& _vec_float6)
{
    m_vec_float6 = std::move(_vec_float6);
    m__d = 13;

}

const std::array<float, 6>& Val::vec_float6() const
{
    bool b = false;

    switch (m__d)
    {
        case 13:
            b = true;
            break;
        default:
            break;
    }

    if (!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_vec_float6;
}

std::array<float, 6>& Val::vec_float6()
{
    bool b = false;

    switch (m__d)
    {
        case 13:
            b = true;
            break;
        default:
            break;
    }

    if (!b)
    {
        throw BadParamException("This member has not been selected");
    }

    return m_vec_float6;
}



Attrib::Attrib()
{

}

Attrib::~Attrib()
{
}

Attrib::Attrib(
        const Attrib& x)
{
    m_type = x.m_type;
    m_value = x.m_value;
    m_timestamp = x.m_timestamp;
    m_agent_id = x.m_agent_id;
}

Attrib::Attrib(
        Attrib&& x) noexcept
{
    m_type = x.m_type;
    m_value = std::move(x.m_value);
    m_timestamp = x.m_timestamp;
    m_agent_id = x.m_agent_id;
}

Attrib& Attrib::operator =(
        const Attrib& x)
{

    m_type = x.m_type;
    m_value = x.m_value;
    m_timestamp = x.m_timestamp;
    m_agent_id = x.m_agent_id;
    return *this;
}

Attrib& Attrib::operator =(
        Attrib&& x) noexcept
{

    m_type = x.m_type;
    m_value = std::move(x.m_value);
    m_timestamp = x.m_timestamp;
    m_agent_id = x.m_agent_id;
    return *this;
}

bool Attrib::operator ==(
        const Attrib& x) const
{
    return (m_type == x.m_type &&
           m_value == x.m_value &&
           m_timestamp == x.m_timestamp &&
           m_agent_id == x.m_agent_id);
}

bool Attrib::operator !=(
        const Attrib& x) const
{
    return !(*this == x);
}

/*!
 * @brief This function sets a value in member type
 * @param _type New value for member type
 */
void Attrib::type(
        uint32_t _type)
{
    m_type = _type;
}

/*!
 * @brief This function returns the value of member type
 * @return Value of member type
 */
uint32_t Attrib::type() const
{
    return m_type;
}

/*!
 * @brief This function returns a reference to member type
 * @return Reference to member type
 */
uint32_t& Attrib::type()
{
    return m_type;
}


/*!
 * @brief This function copies the value in member value
 * @param _value New value to be copied in member value
 */
void Attrib::value(
        const Val& _value)
{
    m_value = _value;
}

/*!
 * @brief This function moves the value in member value
 * @param _value New value to be moved in member value
 */
void Attrib::value(
        Val&& _value)
{
    m_value = std::move(_value);
}

/*!
 * @brief This function returns a constant reference to member value
 * @return Constant reference to member value
 */
const Val& Attrib::value() const
{
    return m_value;
}

/*!
 * @brief This function returns a reference to member value
 * @return Reference to member value
 */
Val& Attrib::value()
{
    return m_value;
}


/*!
 * @brief This function sets a value in member timestamp
 * @param _timestamp New value for member timestamp
 */
void Attrib::timestamp(
        uint64_t _timestamp)
{
    m_timestamp = _timestamp;
}

/*!
 * @brief This function returns the value of member timestamp
 * @return Value of member timestamp
 */
uint64_t Attrib::timestamp() const
{
    return m_timestamp;
}

/*!
 * @brief This function returns a reference to member timestamp
 * @return Reference to member timestamp
 */
uint64_t& Attrib::timestamp()
{
    return m_timestamp;
}


/*!
 * @brief This function sets a value in member agent_id
 * @param _agent_id New value for member agent_id
 */
void Attrib::agent_id(
        uint32_t _agent_id)
{
    m_agent_id = _agent_id;
}

/*!
 * @brief This function returns the value of member agent_id
 * @return Value of member agent_id
 */
uint32_t Attrib::agent_id() const
{
    return m_agent_id;
}

/*!
 * @brief This function returns a reference to member agent_id
 * @return Reference to member agent_id
 */
uint32_t& Attrib::agent_id()
{
    return m_agent_id;
}


PairInt::PairInt()
{

}

PairInt::~PairInt()
{
}

PairInt::PairInt(
        const PairInt& x)
{
    m_first = x.m_first;
    m_second = x.m_second;
}

PairInt::PairInt(
        PairInt&& x) noexcept
{
    m_first = x.m_first;
    m_second = x.m_second;
}

PairInt& PairInt::operator =(
        const PairInt& x)
{

    m_first = x.m_first;
    m_second = x.m_second;
    return *this;
}

PairInt& PairInt::operator =(
        PairInt&& x) noexcept
{

    m_first = x.m_first;
    m_second = x.m_second;
    return *this;
}

bool PairInt::operator ==(
        const PairInt& x) const
{
    return (m_first == x.m_first &&
           m_second == x.m_second);
}

bool PairInt::operator !=(
        const PairInt& x) const
{
    return !(*this == x);
}

/*!
 * @brief This function sets a value in member first
 * @param _first New value for member first
 */
void PairInt::first(
        uint64_t _first)
{
    m_first = _first;
}

/*!
 * @brief This function returns the value of member first
 * @return Value of member first
 */
uint64_t PairInt::first() const
{
    return m_first;
}

/*!
 * @brief This function returns a reference to member first
 * @return Reference to member first
 */
uint64_t& PairInt::first()
{
    return m_first;
}


/*!
 * @brief This function sets a value in member second
 * @param _second New value for member second
 */
void PairInt::second(
        int32_t _second)
{
    m_second = _second;
}

/*!
 * @brief This function returns the value of member second
 * @return Value of member second
 */
int32_t PairInt::second() const
{
    return m_second;
}

/*!
 * @brief This function returns a reference to member second
 * @return Reference to member second
 */
int32_t& PairInt::second()
{
    return m_second;
}


DotContext::DotContext()
{

}

DotContext::~DotContext()
{
}

DotContext::DotContext(
        const DotContext& x)
{
    m_cc = x.m_cc;
    m_dc = x.m_dc;
}

DotContext::DotContext(
        DotContext&& x) noexcept
{
    m_cc = std::move(x.m_cc);
    m_dc = std::move(x.m_dc);
}

DotContext& DotContext::operator =(
        const DotContext& x)
{

    m_cc = x.m_cc;
    m_dc = x.m_dc;
    return *this;
}

DotContext& DotContext::operator =(
        DotContext&& x) noexcept
{

    m_cc = std::move(x.m_cc);
    m_dc = std::move(x.m_dc);
    return *this;
}

bool DotContext::operator ==(
        const DotContext& x) const
{
    return (m_cc == x.m_cc &&
           m_dc == x.m_dc);
}

bool DotContext::operator !=(
        const DotContext& x) const
{
    return !(*this == x);
}

/*!
 * @brief This function copies the value in member cc
 * @param _cc New value to be copied in member cc
 */
void DotContext::cc(
        const std::map<uint64_t, int32_t>& _cc)
{
    m_cc = _cc;
}

/*!
 * @brief This function moves the value in member cc
 * @param _cc New value to be moved in member cc
 */
void DotContext::cc(
        std::map<uint64_t, int32_t>&& _cc)
{
    m_cc = std::move(_cc);
}

/*!
 * @brief This function returns a constant reference to member cc
 * @return Constant reference to member cc
 */
const std::map<uint64_t, int32_t>& DotContext::cc() const
{
    return m_cc;
}

/*!
 * @brief This function returns a reference to member cc
 * @return Reference to member cc
 */
std::map<uint64_t, int32_t>& DotContext::cc()
{
    return m_cc;
}


/*!
 * @brief This function copies the value in member dc
 * @param _dc New value to be copied in member dc
 */
void DotContext::dc(
        const std::vector<PairInt>& _dc)
{
    m_dc = _dc;
}

/*!
 * @brief This function moves the value in member dc
 * @param _dc New value to be moved in member dc
 */
void DotContext::dc(
        std::vector<PairInt>&& _dc)
{
    m_dc = std::move(_dc);
}

/*!
 * @brief This function returns a constant reference to member dc
 * @return Constant reference to member dc
 */
const std::vector<PairInt>& DotContext::dc() const
{
    return m_dc;
}

/*!
 * @brief This function returns a reference to member dc
 * @return Reference to member dc
 */
std::vector<PairInt>& DotContext::dc()
{
    return m_dc;
}


DotKernelAttr::DotKernelAttr()
{

}

DotKernelAttr::~DotKernelAttr()
{
}

DotKernelAttr::DotKernelAttr(
        const DotKernelAttr& x)
{
    m_ds = x.m_ds;
    m_cbase = x.m_cbase;
}

DotKernelAttr::DotKernelAttr(
        DotKernelAttr&& x) noexcept
{
    m_ds = std::move(x.m_ds);
    m_cbase = std::move(x.m_cbase);
}

DotKernelAttr& DotKernelAttr::operator =(
        const DotKernelAttr& x)
{

    m_ds = x.m_ds;
    m_cbase = x.m_cbase;
    return *this;
}

DotKernelAttr& DotKernelAttr::operator =(
        DotKernelAttr&& x) noexcept
{

    m_ds = std::move(x.m_ds);
    m_cbase = std::move(x.m_cbase);
    return *this;
}

bool DotKernelAttr::operator ==(
        const DotKernelAttr& x) const
{
    return (m_ds == x.m_ds &&
           m_cbase == x.m_cbase);
}

bool DotKernelAttr::operator !=(
        const DotKernelAttr& x) const
{
    return !(*this == x);
}

/*!
 * @brief This function copies the value in member ds
 * @param _ds New value to be copied in member ds
 */
void DotKernelAttr::ds(
        const std::map<PairInt, Attrib>& _ds)
{
    m_ds = _ds;
}

/*!
 * @brief This function moves the value in member ds
 * @param _ds New value to be moved in member ds
 */
void DotKernelAttr::ds(
        std::map<PairInt, Attrib>&& _ds)
{
    m_ds = std::move(_ds);
}

/*!
 * @brief This function returns a constant reference to member ds
 * @return Constant reference to member ds
 */
const std::map<PairInt, Attrib>& DotKernelAttr::ds() const
{
    return m_ds;
}

/*!
 * @brief This function returns a reference to member ds
 * @return Reference to member ds
 */
std::map<PairInt, Attrib>& DotKernelAttr::ds()
{
    return m_ds;
}


/*!
 * @brief This function copies the value in member cbase
 * @param _cbase New value to be copied in member cbase
 */
void DotKernelAttr::cbase(
        const DotContext& _cbase)
{
    m_cbase = _cbase;
}

/*!
 * @brief This function moves the value in member cbase
 * @param _cbase New value to be moved in member cbase
 */
void DotKernelAttr::cbase(
        DotContext&& _cbase)
{
    m_cbase = std::move(_cbase);
}

/*!
 * @brief This function returns a constant reference to member cbase
 * @return Constant reference to member cbase
 */
const DotContext& DotKernelAttr::cbase() const
{
    return m_cbase;
}

/*!
 * @brief This function returns a reference to member cbase
 * @return Reference to member cbase
 */
DotContext& DotKernelAttr::cbase()
{
    return m_cbase;
}


MvregEdgeAttr::MvregEdgeAttr()
{

}

MvregEdgeAttr::~MvregEdgeAttr()
{
}

MvregEdgeAttr::MvregEdgeAttr(
        const MvregEdgeAttr& x)
{
    m_id = x.m_id;
    m_from = x.m_from;
    m_to = x.m_to;
    m_type = x.m_type;
    m_attr_name = x.m_attr_name;
    m_dk = x.m_dk;
    m_agent_id = x.m_agent_id;
    m_timestamp = x.m_timestamp;
}

MvregEdgeAttr::MvregEdgeAttr(
        MvregEdgeAttr&& x) noexcept
{
    m_id = x.m_id;
    m_from = x.m_from;
    m_to = x.m_to;
    m_type = std::move(x.m_type);
    m_attr_name = std::move(x.m_attr_name);
    m_dk = std::move(x.m_dk);
    m_agent_id = x.m_agent_id;
    m_timestamp = x.m_timestamp;
}

MvregEdgeAttr& MvregEdgeAttr::operator =(
        const MvregEdgeAttr& x)
{

    m_id = x.m_id;
    m_from = x.m_from;
    m_to = x.m_to;
    m_type = x.m_type;
    m_attr_name = x.m_attr_name;
    m_dk = x.m_dk;
    m_agent_id = x.m_agent_id;
    m_timestamp = x.m_timestamp;
    return *this;
}

MvregEdgeAttr& MvregEdgeAttr::operator =(
        MvregEdgeAttr&& x) noexcept
{

    m_id = x.m_id;
    m_from = x.m_from;
    m_to = x.m_to;
    m_type = std::move(x.m_type);
    m_attr_name = std::move(x.m_attr_name);
    m_dk = std::move(x.m_dk);
    m_agent_id = x.m_agent_id;
    m_timestamp = x.m_timestamp;
    return *this;
}

bool MvregEdgeAttr::operator ==(
        const MvregEdgeAttr& x) const
{
    return (m_id == x.m_id &&
           m_from == x.m_from &&
           m_to == x.m_to &&
           m_type == x.m_type &&
           m_attr_name == x.m_attr_name &&
           m_dk == x.m_dk &&
           m_agent_id == x.m_agent_id &&
           m_timestamp == x.m_timestamp);
}

bool MvregEdgeAttr::operator !=(
        const MvregEdgeAttr& x) const
{
    return !(*this == x);
}

/*!
 * @brief This function sets a value in member id
 * @param _id New value for member id
 */
void MvregEdgeAttr::id(
        uint64_t _id)
{
    m_id = _id;
}

/*!
 * @brief This function returns the value of member id
 * @return Value of member id
 */
uint64_t MvregEdgeAttr::id() const
{
    return m_id;
}

/*!
 * @brief This function returns a reference to member id
 * @return Reference to member id
 */
uint64_t& MvregEdgeAttr::id()
{
    return m_id;
}


/*!
 * @brief This function sets a value in member from
 * @param _from New value for member from
 */
void MvregEdgeAttr::from(
        uint64_t _from)
{
    m_from = _from;
}

/*!
 * @brief This function returns the value of member from
 * @return Value of member from
 */
uint64_t MvregEdgeAttr::from() const
{
    return m_from;
}

/*!
 * @brief This function returns a reference to member from
 * @return Reference to member from
 */
uint64_t& MvregEdgeAttr::from()
{
    return m_from;
}


/*!
 * @brief This function sets a value in member to
 * @param _to New value for member to
 */
void MvregEdgeAttr::to(
        uint64_t _to)
{
    m_to = _to;
}

/*!
 * @brief This function returns the value of member to
 * @return Value of member to
 */
uint64_t MvregEdgeAttr::to() const
{
    return m_to;
}

/*!
 * @brief This function returns a reference to member to
 * @return Reference to member to
 */
uint64_t& MvregEdgeAttr::to()
{
    return m_to;
}


/*!
 * @brief This function copies the value in member type
 * @param _type New value to be copied in member type
 */
void MvregEdgeAttr::type(
        const std::string& _type)
{
    m_type = _type;
}

/*!
 * @brief This function moves the value in member type
 * @param _type New value to be moved in member type
 */
void MvregEdgeAttr::type(
        std::string&& _type)
{
    m_type = std::move(_type);
}

/*!
 * @brief This function returns a constant reference to member type
 * @return Constant reference to member type
 */
const std::string& MvregEdgeAttr::type() const
{
    return m_type;
}

/*!
 * @brief This function returns a reference to member type
 * @return Reference to member type
 */
std::string& MvregEdgeAttr::type()
{
    return m_type;
}


/*!
 * @brief This function copies the value in member attr_name
 * @param _attr_name New value to be copied in member attr_name
 */
void MvregEdgeAttr::attr_name(
        const std::string& _attr_name)
{
    m_attr_name = _attr_name;
}

/*!
 * @brief This function moves the value in member attr_name
 * @param _attr_name New value to be moved in member attr_name
 */
void MvregEdgeAttr::attr_name(
        std::string&& _attr_name)
{
    m_attr_name = std::move(_attr_name);
}

/*!
 * @brief This function returns a constant reference to member attr_name
 * @return Constant reference to member attr_name
 */
const std::string& MvregEdgeAttr::attr_name() const
{
    return m_attr_name;
}

/*!
 * @brief This function returns a reference to member attr_name
 * @return Reference to member attr_name
 */
std::string& MvregEdgeAttr::attr_name()
{
    return m_attr_name;
}


/*!
 * @brief This function copies the value in member dk
 * @param _dk New value to be copied in member dk
 */
void MvregEdgeAttr::dk(
        const DotKernelAttr& _dk)
{
    m_dk = _dk;
}

/*!
 * @brief This function moves the value in member dk
 * @param _dk New value to be moved in member dk
 */
void MvregEdgeAttr::dk(
        DotKernelAttr&& _dk)
{
    m_dk = std::move(_dk);
}

/*!
 * @brief This function returns a constant reference to member dk
 * @return Constant reference to member dk
 */
const DotKernelAttr& MvregEdgeAttr::dk() const
{
    return m_dk;
}

/*!
 * @brief This function returns a reference to member dk
 * @return Reference to member dk
 */
DotKernelAttr& MvregEdgeAttr::dk()
{
    return m_dk;
}


/*!
 * @brief This function sets a value in member agent_id
 * @param _agent_id New value for member agent_id
 */
void MvregEdgeAttr::agent_id(
        uint32_t _agent_id)
{
    m_agent_id = _agent_id;
}

/*!
 * @brief This function returns the value of member agent_id
 * @return Value of member agent_id
 */
uint32_t MvregEdgeAttr::agent_id() const
{
    return m_agent_id;
}

/*!
 * @brief This function returns a reference to member agent_id
 * @return Reference to member agent_id
 */
uint32_t& MvregEdgeAttr::agent_id()
{
    return m_agent_id;
}


/*!
 * @brief This function sets a value in member timestamp
 * @param _timestamp New value for member timestamp
 */
void MvregEdgeAttr::timestamp(
        uint64_t _timestamp)
{
    m_timestamp = _timestamp;
}

/*!
 * @brief This function returns the value of member timestamp
 * @return Value of member timestamp
 */
uint64_t MvregEdgeAttr::timestamp() const
{
    return m_timestamp;
}

/*!
 * @brief This function returns a reference to member timestamp
 * @return Reference to member timestamp
 */
uint64_t& MvregEdgeAttr::timestamp()
{
    return m_timestamp;
}


IDLEdge::IDLEdge()
{

}

IDLEdge::~IDLEdge()
{
}

IDLEdge::IDLEdge(
        const IDLEdge& x)
{
    m_to = x.m_to;
    m_type = x.m_type;
    m_from = x.m_from;
    m_attrs = x.m_attrs;
    m_agent_id = x.m_agent_id;
}

IDLEdge::IDLEdge(
        IDLEdge&& x) noexcept
{
    m_to = x.m_to;
    m_type = std::move(x.m_type);
    m_from = x.m_from;
    m_attrs = std::move(x.m_attrs);
    m_agent_id = x.m_agent_id;
}

IDLEdge& IDLEdge::operator =(
        const IDLEdge& x)
{

    m_to = x.m_to;
    m_type = x.m_type;
    m_from = x.m_from;
    m_attrs = x.m_attrs;
    m_agent_id = x.m_agent_id;
    return *this;
}

IDLEdge& IDLEdge::operator =(
        IDLEdge&& x) noexcept
{

    m_to = x.m_to;
    m_type = std::move(x.m_type);
    m_from = x.m_from;
    m_attrs = std::move(x.m_attrs);
    m_agent_id = x.m_agent_id;
    return *this;
}

bool IDLEdge::operator ==(
        const IDLEdge& x) const
{
    return (m_to == x.m_to &&
           m_type == x.m_type &&
           m_from == x.m_from &&
           m_attrs == x.m_attrs &&
           m_agent_id == x.m_agent_id);
}

bool IDLEdge::operator !=(
        const IDLEdge& x) const
{
    return !(*this == x);
}

/*!
 * @brief This function sets a value in member to
 * @param _to New value for member to
 */
void IDLEdge::to(
        uint64_t _to)
{
    m_to = _to;
}

/*!
 * @brief This function returns the value of member to
 * @return Value of member to
 */
uint64_t IDLEdge::to() const
{
    return m_to;
}

/*!
 * @brief This function returns a reference to member to
 * @return Reference to member to
 */
uint64_t& IDLEdge::to()
{
    return m_to;
}


/*!
 * @brief This function copies the value in member type
 * @param _type New value to be copied in member type
 */
void IDLEdge::type(
        const std::string& _type)
{
    m_type = _type;
}

/*!
 * @brief This function moves the value in member type
 * @param _type New value to be moved in member type
 */
void IDLEdge::type(
        std::string&& _type)
{
    m_type = std::move(_type);
}

/*!
 * @brief This function returns a constant reference to member type
 * @return Constant reference to member type
 */
const std::string& IDLEdge::type() const
{
    return m_type;
}

/*!
 * @brief This function returns a reference to member type
 * @return Reference to member type
 */
std::string& IDLEdge::type()
{
    return m_type;
}


/*!
 * @brief This function sets a value in member from
 * @param _from New value for member from
 */
void IDLEdge::from(
        uint64_t _from)
{
    m_from = _from;
}

/*!
 * @brief This function returns the value of member from
 * @return Value of member from
 */
uint64_t IDLEdge::from() const
{
    return m_from;
}

/*!
 * @brief This function returns a reference to member from
 * @return Reference to member from
 */
uint64_t& IDLEdge::from()
{
    return m_from;
}


/*!
 * @brief This function copies the value in member attrs
 * @param _attrs New value to be copied in member attrs
 */
void IDLEdge::attrs(
        const std::map<std::string, MvregEdgeAttr>& _attrs)
{
    m_attrs = _attrs;
}

/*!
 * @brief This function moves the value in member attrs
 * @param _attrs New value to be moved in member attrs
 */
void IDLEdge::attrs(
        std::map<std::string, MvregEdgeAttr>&& _attrs)
{
    m_attrs = std::move(_attrs);
}

/*!
 * @brief This function returns a constant reference to member attrs
 * @return Constant reference to member attrs
 */
const std::map<std::string, MvregEdgeAttr>& IDLEdge::attrs() const
{
    return m_attrs;
}

/*!
 * @brief This function returns a reference to member attrs
 * @return Reference to member attrs
 */
std::map<std::string, MvregEdgeAttr>& IDLEdge::attrs()
{
    return m_attrs;
}


/*!
 * @brief This function sets a value in member agent_id
 * @param _agent_id New value for member agent_id
 */
void IDLEdge::agent_id(
        uint32_t _agent_id)
{
    m_agent_id = _agent_id;
}

/*!
 * @brief This function returns the value of member agent_id
 * @return Value of member agent_id
 */
uint32_t IDLEdge::agent_id() const
{
    return m_agent_id;
}

/*!
 * @brief This function returns a reference to member agent_id
 * @return Reference to member agent_id
 */
uint32_t& IDLEdge::agent_id()
{
    return m_agent_id;
}


EdgeKey::EdgeKey()
{

}

EdgeKey::~EdgeKey()
{
}

EdgeKey::EdgeKey(
        const EdgeKey& x)
{
    m_to = x.m_to;
    m_type = x.m_type;
}

EdgeKey::EdgeKey(
        EdgeKey&& x) noexcept
{
    m_to = x.m_to;
    m_type = std::move(x.m_type);
}

EdgeKey& EdgeKey::operator =(
        const EdgeKey& x)
{

    m_to = x.m_to;
    m_type = x.m_type;
    return *this;
}

EdgeKey& EdgeKey::operator =(
        EdgeKey&& x) noexcept
{

    m_to = x.m_to;
    m_type = std::move(x.m_type);
    return *this;
}

bool EdgeKey::operator ==(
        const EdgeKey& x) const
{
    return (m_to == x.m_to &&
           m_type == x.m_type);
}

bool EdgeKey::operator !=(
        const EdgeKey& x) const
{
    return !(*this == x);
}

/*!
 * @brief This function sets a value in member to
 * @param _to New value for member to
 */
void EdgeKey::to(
        uint64_t _to)
{
    m_to = _to;
}

/*!
 * @brief This function returns the value of member to
 * @return Value of member to
 */
uint64_t EdgeKey::to() const
{
    return m_to;
}

/*!
 * @brief This function returns a reference to member to
 * @return Reference to member to
 */
uint64_t& EdgeKey::to()
{
    return m_to;
}


/*!
 * @brief This function copies the value in member type
 * @param _type New value to be copied in member type
 */
void EdgeKey::type(
        const std::string& _type)
{
    m_type = _type;
}

/*!
 * @brief This function moves the value in member type
 * @param _type New value to be moved in member type
 */
void EdgeKey::type(
        std::string&& _type)
{
    m_type = std::move(_type);
}

/*!
 * @brief This function returns a constant reference to member type
 * @return Constant reference to member type
 */
const std::string& EdgeKey::type() const
{
    return m_type;
}

/*!
 * @brief This function returns a reference to member type
 * @return Reference to member type
 */
std::string& EdgeKey::type()
{
    return m_type;
}


MvregNodeAttr::MvregNodeAttr()
{

}

MvregNodeAttr::~MvregNodeAttr()
{
}

MvregNodeAttr::MvregNodeAttr(
        const MvregNodeAttr& x)
{
    m_id = x.m_id;
    m_node = x.m_node;
    m_attr_name = x.m_attr_name;
    m_dk = x.m_dk;
    m_agent_id = x.m_agent_id;
    m_timestamp = x.m_timestamp;
}

MvregNodeAttr::MvregNodeAttr(
        MvregNodeAttr&& x) noexcept
{
    m_id = x.m_id;
    m_node = x.m_node;
    m_attr_name = std::move(x.m_attr_name);
    m_dk = std::move(x.m_dk);
    m_agent_id = x.m_agent_id;
    m_timestamp = x.m_timestamp;
}

MvregNodeAttr& MvregNodeAttr::operator =(
        const MvregNodeAttr& x)
{

    m_id = x.m_id;
    m_node = x.m_node;
    m_attr_name = x.m_attr_name;
    m_dk = x.m_dk;
    m_agent_id = x.m_agent_id;
    m_timestamp = x.m_timestamp;
    return *this;
}

MvregNodeAttr& MvregNodeAttr::operator =(
        MvregNodeAttr&& x) noexcept
{

    m_id = x.m_id;
    m_node = x.m_node;
    m_attr_name = std::move(x.m_attr_name);
    m_dk = std::move(x.m_dk);
    m_agent_id = x.m_agent_id;
    m_timestamp = x.m_timestamp;
    return *this;
}

bool MvregNodeAttr::operator ==(
        const MvregNodeAttr& x) const
{
    return (m_id == x.m_id &&
           m_node == x.m_node &&
           m_attr_name == x.m_attr_name &&
           m_dk == x.m_dk &&
           m_agent_id == x.m_agent_id &&
           m_timestamp == x.m_timestamp);
}

bool MvregNodeAttr::operator !=(
        const MvregNodeAttr& x) const
{
    return !(*this == x);
}

/*!
 * @brief This function sets a value in member id
 * @param _id New value for member id
 */
void MvregNodeAttr::id(
        uint64_t _id)
{
    m_id = _id;
}

/*!
 * @brief This function returns the value of member id
 * @return Value of member id
 */
uint64_t MvregNodeAttr::id() const
{
    return m_id;
}

/*!
 * @brief This function returns a reference to member id
 * @return Reference to member id
 */
uint64_t& MvregNodeAttr::id()
{
    return m_id;
}


/*!
 * @brief This function sets a value in member node
 * @param _node New value for member node
 */
void MvregNodeAttr::node(
        uint64_t _node)
{
    m_node = _node;
}

/*!
 * @brief This function returns the value of member node
 * @return Value of member node
 */
uint64_t MvregNodeAttr::node() const
{
    return m_node;
}

/*!
 * @brief This function returns a reference to member node
 * @return Reference to member node
 */
uint64_t& MvregNodeAttr::node()
{
    return m_node;
}


/*!
 * @brief This function copies the value in member attr_name
 * @param _attr_name New value to be copied in member attr_name
 */
void MvregNodeAttr::attr_name(
        const std::string& _attr_name)
{
    m_attr_name = _attr_name;
}

/*!
 * @brief This function moves the value in member attr_name
 * @param _attr_name New value to be moved in member attr_name
 */
void MvregNodeAttr::attr_name(
        std::string&& _attr_name)
{
    m_attr_name = std::move(_attr_name);
}

/*!
 * @brief This function returns a constant reference to member attr_name
 * @return Constant reference to member attr_name
 */
const std::string& MvregNodeAttr::attr_name() const
{
    return m_attr_name;
}

/*!
 * @brief This function returns a reference to member attr_name
 * @return Reference to member attr_name
 */
std::string& MvregNodeAttr::attr_name()
{
    return m_attr_name;
}


/*!
 * @brief This function copies the value in member dk
 * @param _dk New value to be copied in member dk
 */
void MvregNodeAttr::dk(
        const DotKernelAttr& _dk)
{
    m_dk = _dk;
}

/*!
 * @brief This function moves the value in member dk
 * @param _dk New value to be moved in member dk
 */
void MvregNodeAttr::dk(
        DotKernelAttr&& _dk)
{
    m_dk = std::move(_dk);
}

/*!
 * @brief This function returns a constant reference to member dk
 * @return Constant reference to member dk
 */
const DotKernelAttr& MvregNodeAttr::dk() const
{
    return m_dk;
}

/*!
 * @brief This function returns a reference to member dk
 * @return Reference to member dk
 */
DotKernelAttr& MvregNodeAttr::dk()
{
    return m_dk;
}


/*!
 * @brief This function sets a value in member agent_id
 * @param _agent_id New value for member agent_id
 */
void MvregNodeAttr::agent_id(
        uint32_t _agent_id)
{
    m_agent_id = _agent_id;
}

/*!
 * @brief This function returns the value of member agent_id
 * @return Value of member agent_id
 */
uint32_t MvregNodeAttr::agent_id() const
{
    return m_agent_id;
}

/*!
 * @brief This function returns a reference to member agent_id
 * @return Reference to member agent_id
 */
uint32_t& MvregNodeAttr::agent_id()
{
    return m_agent_id;
}


/*!
 * @brief This function sets a value in member timestamp
 * @param _timestamp New value for member timestamp
 */
void MvregNodeAttr::timestamp(
        uint64_t _timestamp)
{
    m_timestamp = _timestamp;
}

/*!
 * @brief This function returns the value of member timestamp
 * @return Value of member timestamp
 */
uint64_t MvregNodeAttr::timestamp() const
{
    return m_timestamp;
}

/*!
 * @brief This function returns a reference to member timestamp
 * @return Reference to member timestamp
 */
uint64_t& MvregNodeAttr::timestamp()
{
    return m_timestamp;
}


DotKernelEdge::DotKernelEdge()
{

}

DotKernelEdge::~DotKernelEdge()
{
}

DotKernelEdge::DotKernelEdge(
        const DotKernelEdge& x)
{
    m_ds = x.m_ds;
    m_cbase = x.m_cbase;
}

DotKernelEdge::DotKernelEdge(
        DotKernelEdge&& x) noexcept
{
    m_ds = std::move(x.m_ds);
    m_cbase = std::move(x.m_cbase);
}

DotKernelEdge& DotKernelEdge::operator =(
        const DotKernelEdge& x)
{

    m_ds = x.m_ds;
    m_cbase = x.m_cbase;
    return *this;
}

DotKernelEdge& DotKernelEdge::operator =(
        DotKernelEdge&& x) noexcept
{

    m_ds = std::move(x.m_ds);
    m_cbase = std::move(x.m_cbase);
    return *this;
}

bool DotKernelEdge::operator ==(
        const DotKernelEdge& x) const
{
    return (m_ds == x.m_ds &&
           m_cbase == x.m_cbase);
}

bool DotKernelEdge::operator !=(
        const DotKernelEdge& x) const
{
    return !(*this == x);
}

/*!
 * @brief This function copies the value in member ds
 * @param _ds New value to be copied in member ds
 */
void DotKernelEdge::ds(
        const std::map<PairInt, IDLEdge>& _ds)
{
    m_ds = _ds;
}

/*!
 * @brief This function moves the value in member ds
 * @param _ds New value to be moved in member ds
 */
void DotKernelEdge::ds(
        std::map<PairInt, IDLEdge>&& _ds)
{
    m_ds = std::move(_ds);
}

/*!
 * @brief This function returns a constant reference to member ds
 * @return Constant reference to member ds
 */
const std::map<PairInt, IDLEdge>& DotKernelEdge::ds() const
{
    return m_ds;
}

/*!
 * @brief This function returns a reference to member ds
 * @return Reference to member ds
 */
std::map<PairInt, IDLEdge>& DotKernelEdge::ds()
{
    return m_ds;
}


/*!
 * @brief This function copies the value in member cbase
 * @param _cbase New value to be copied in member cbase
 */
void DotKernelEdge::cbase(
        const DotContext& _cbase)
{
    m_cbase = _cbase;
}

/*!
 * @brief This function moves the value in member cbase
 * @param _cbase New value to be moved in member cbase
 */
void DotKernelEdge::cbase(
        DotContext&& _cbase)
{
    m_cbase = std::move(_cbase);
}

/*!
 * @brief This function returns a constant reference to member cbase
 * @return Constant reference to member cbase
 */
const DotContext& DotKernelEdge::cbase() const
{
    return m_cbase;
}

/*!
 * @brief This function returns a reference to member cbase
 * @return Reference to member cbase
 */
DotContext& DotKernelEdge::cbase()
{
    return m_cbase;
}


MvregEdge::MvregEdge()
{

}

MvregEdge::~MvregEdge()
{
}

MvregEdge::MvregEdge(
        const MvregEdge& x)
{
    m_id = x.m_id;
    m_from = x.m_from;
    m_to = x.m_to;
    m_type = x.m_type;
    m_dk = x.m_dk;
    m_agent_id = x.m_agent_id;
    m_timestamp = x.m_timestamp;
}

MvregEdge::MvregEdge(
        MvregEdge&& x) noexcept
{
    m_id = x.m_id;
    m_from = x.m_from;
    m_to = x.m_to;
    m_type = std::move(x.m_type);
    m_dk = std::move(x.m_dk);
    m_agent_id = x.m_agent_id;
    m_timestamp = x.m_timestamp;
}

MvregEdge& MvregEdge::operator =(
        const MvregEdge& x)
{

    m_id = x.m_id;
    m_from = x.m_from;
    m_to = x.m_to;
    m_type = x.m_type;
    m_dk = x.m_dk;
    m_agent_id = x.m_agent_id;
    m_timestamp = x.m_timestamp;
    return *this;
}

MvregEdge& MvregEdge::operator =(
        MvregEdge&& x) noexcept
{

    m_id = x.m_id;
    m_from = x.m_from;
    m_to = x.m_to;
    m_type = std::move(x.m_type);
    m_dk = std::move(x.m_dk);
    m_agent_id = x.m_agent_id;
    m_timestamp = x.m_timestamp;
    return *this;
}

bool MvregEdge::operator ==(
        const MvregEdge& x) const
{
    return (m_id == x.m_id &&
           m_from == x.m_from &&
           m_to == x.m_to &&
           m_type == x.m_type &&
           m_dk == x.m_dk &&
           m_agent_id == x.m_agent_id &&
           m_timestamp == x.m_timestamp);
}

bool MvregEdge::operator !=(
        const MvregEdge& x) const
{
    return !(*this == x);
}

/*!
 * @brief This function sets a value in member id
 * @param _id New value for member id
 */
void MvregEdge::id(
        uint64_t _id)
{
    m_id = _id;
}

/*!
 * @brief This function returns the value of member id
 * @return Value of member id
 */
uint64_t MvregEdge::id() const
{
    return m_id;
}

/*!
 * @brief This function returns a reference to member id
 * @return Reference to member id
 */
uint64_t& MvregEdge::id()
{
    return m_id;
}


/*!
 * @brief This function sets a value in member from
 * @param _from New value for member from
 */
void MvregEdge::from(
        uint64_t _from)
{
    m_from = _from;
}

/*!
 * @brief This function returns the value of member from
 * @return Value of member from
 */
uint64_t MvregEdge::from() const
{
    return m_from;
}

/*!
 * @brief This function returns a reference to member from
 * @return Reference to member from
 */
uint64_t& MvregEdge::from()
{
    return m_from;
}


/*!
 * @brief This function sets a value in member to
 * @param _to New value for member to
 */
void MvregEdge::to(
        uint64_t _to)
{
    m_to = _to;
}

/*!
 * @brief This function returns the value of member to
 * @return Value of member to
 */
uint64_t MvregEdge::to() const
{
    return m_to;
}

/*!
 * @brief This function returns a reference to member to
 * @return Reference to member to
 */
uint64_t& MvregEdge::to()
{
    return m_to;
}


/*!
 * @brief This function copies the value in member type
 * @param _type New value to be copied in member type
 */
void MvregEdge::type(
        const std::string& _type)
{
    m_type = _type;
}

/*!
 * @brief This function moves the value in member type
 * @param _type New value to be moved in member type
 */
void MvregEdge::type(
        std::string&& _type)
{
    m_type = std::move(_type);
}

/*!
 * @brief This function returns a constant reference to member type
 * @return Constant reference to member type
 */
const std::string& MvregEdge::type() const
{
    return m_type;
}

/*!
 * @brief This function returns a reference to member type
 * @return Reference to member type
 */
std::string& MvregEdge::type()
{
    return m_type;
}


/*!
 * @brief This function copies the value in member dk
 * @param _dk New value to be copied in member dk
 */
void MvregEdge::dk(
        const DotKernelEdge& _dk)
{
    m_dk = _dk;
}

/*!
 * @brief This function moves the value in member dk
 * @param _dk New value to be moved in member dk
 */
void MvregEdge::dk(
        DotKernelEdge&& _dk)
{
    m_dk = std::move(_dk);
}

/*!
 * @brief This function returns a constant reference to member dk
 * @return Constant reference to member dk
 */
const DotKernelEdge& MvregEdge::dk() const
{
    return m_dk;
}

/*!
 * @brief This function returns a reference to member dk
 * @return Reference to member dk
 */
DotKernelEdge& MvregEdge::dk()
{
    return m_dk;
}


/*!
 * @brief This function sets a value in member agent_id
 * @param _agent_id New value for member agent_id
 */
void MvregEdge::agent_id(
        uint32_t _agent_id)
{
    m_agent_id = _agent_id;
}

/*!
 * @brief This function returns the value of member agent_id
 * @return Value of member agent_id
 */
uint32_t MvregEdge::agent_id() const
{
    return m_agent_id;
}

/*!
 * @brief This function returns a reference to member agent_id
 * @return Reference to member agent_id
 */
uint32_t& MvregEdge::agent_id()
{
    return m_agent_id;
}


/*!
 * @brief This function sets a value in member timestamp
 * @param _timestamp New value for member timestamp
 */
void MvregEdge::timestamp(
        uint64_t _timestamp)
{
    m_timestamp = _timestamp;
}

/*!
 * @brief This function returns the value of member timestamp
 * @return Value of member timestamp
 */
uint64_t MvregEdge::timestamp() const
{
    return m_timestamp;
}

/*!
 * @brief This function returns a reference to member timestamp
 * @return Reference to member timestamp
 */
uint64_t& MvregEdge::timestamp()
{
    return m_timestamp;
}


IDLNode::IDLNode()
{

}

IDLNode::~IDLNode()
{
}

IDLNode::IDLNode(
        const IDLNode& x)
{
    m_type = x.m_type;
    m_name = x.m_name;
    m_id = x.m_id;
    m_agent_id = x.m_agent_id;
    m_attrs = x.m_attrs;
    m_fano = x.m_fano;
}

IDLNode::IDLNode(
        IDLNode&& x) noexcept
{
    m_type = std::move(x.m_type);
    m_name = std::move(x.m_name);
    m_id = x.m_id;
    m_agent_id = x.m_agent_id;
    m_attrs = std::move(x.m_attrs);
    m_fano = std::move(x.m_fano);
}

IDLNode& IDLNode::operator =(
        const IDLNode& x)
{

    m_type = x.m_type;
    m_name = x.m_name;
    m_id = x.m_id;
    m_agent_id = x.m_agent_id;
    m_attrs = x.m_attrs;
    m_fano = x.m_fano;
    return *this;
}

IDLNode& IDLNode::operator =(
        IDLNode&& x) noexcept
{

    m_type = std::move(x.m_type);
    m_name = std::move(x.m_name);
    m_id = x.m_id;
    m_agent_id = x.m_agent_id;
    m_attrs = std::move(x.m_attrs);
    m_fano = std::move(x.m_fano);
    return *this;
}

bool IDLNode::operator ==(
        const IDLNode& x) const
{
    return (m_type == x.m_type &&
           m_name == x.m_name &&
           m_id == x.m_id &&
           m_agent_id == x.m_agent_id &&
           m_attrs == x.m_attrs &&
           m_fano == x.m_fano);
}

bool IDLNode::operator !=(
        const IDLNode& x) const
{
    return !(*this == x);
}

/*!
 * @brief This function copies the value in member type
 * @param _type New value to be copied in member type
 */
void IDLNode::type(
        const std::string& _type)
{
    m_type = _type;
}

/*!
 * @brief This function moves the value in member type
 * @param _type New value to be moved in member type
 */
void IDLNode::type(
        std::string&& _type)
{
    m_type = std::move(_type);
}

/*!
 * @brief This function returns a constant reference to member type
 * @return Constant reference to member type
 */
const std::string& IDLNode::type() const
{
    return m_type;
}

/*!
 * @brief This function returns a reference to member type
 * @return Reference to member type
 */
std::string& IDLNode::type()
{
    return m_type;
}


/*!
 * @brief This function copies the value in member name
 * @param _name New value to be copied in member name
 */
void IDLNode::name(
        const std::string& _name)
{
    m_name = _name;
}

/*!
 * @brief This function moves the value in member name
 * @param _name New value to be moved in member name
 */
void IDLNode::name(
        std::string&& _name)
{
    m_name = std::move(_name);
}

/*!
 * @brief This function returns a constant reference to member name
 * @return Constant reference to member name
 */
const std::string& IDLNode::name() const
{
    return m_name;
}

/*!
 * @brief This function returns a reference to member name
 * @return Reference to member name
 */
std::string& IDLNode::name()
{
    return m_name;
}


/*!
 * @brief This function sets a value in member id
 * @param _id New value for member id
 */
void IDLNode::id(
        uint64_t _id)
{
    m_id = _id;
}

/*!
 * @brief This function returns the value of member id
 * @return Value of member id
 */
uint64_t IDLNode::id() const
{
    return m_id;
}

/*!
 * @brief This function returns a reference to member id
 * @return Reference to member id
 */
uint64_t& IDLNode::id()
{
    return m_id;
}


/*!
 * @brief This function sets a value in member agent_id
 * @param _agent_id New value for member agent_id
 */
void IDLNode::agent_id(
        uint32_t _agent_id)
{
    m_agent_id = _agent_id;
}

/*!
 * @brief This function returns the value of member agent_id
 * @return Value of member agent_id
 */
uint32_t IDLNode::agent_id() const
{
    return m_agent_id;
}

/*!
 * @brief This function returns a reference to member agent_id
 * @return Reference to member agent_id
 */
uint32_t& IDLNode::agent_id()
{
    return m_agent_id;
}


/*!
 * @brief This function copies the value in member attrs
 * @param _attrs New value to be copied in member attrs
 */
void IDLNode::attrs(
        const std::map<std::string, MvregNodeAttr>& _attrs)
{
    m_attrs = _attrs;
}

/*!
 * @brief This function moves the value in member attrs
 * @param _attrs New value to be moved in member attrs
 */
void IDLNode::attrs(
        std::map<std::string, MvregNodeAttr>&& _attrs)
{
    m_attrs = std::move(_attrs);
}

/*!
 * @brief This function returns a constant reference to member attrs
 * @return Constant reference to member attrs
 */
const std::map<std::string, MvregNodeAttr>& IDLNode::attrs() const
{
    return m_attrs;
}

/*!
 * @brief This function returns a reference to member attrs
 * @return Reference to member attrs
 */
std::map<std::string, MvregNodeAttr>& IDLNode::attrs()
{
    return m_attrs;
}


/*!
 * @brief This function copies the value in member fano
 * @param _fano New value to be copied in member fano
 */
void IDLNode::fano(
        const std::map<EdgeKey, MvregEdge>& _fano)
{
    m_fano = _fano;
}

/*!
 * @brief This function moves the value in member fano
 * @param _fano New value to be moved in member fano
 */
void IDLNode::fano(
        std::map<EdgeKey, MvregEdge>&& _fano)
{
    m_fano = std::move(_fano);
}

/*!
 * @brief This function returns a constant reference to member fano
 * @return Constant reference to member fano
 */
const std::map<EdgeKey, MvregEdge>& IDLNode::fano() const
{
    return m_fano;
}

/*!
 * @brief This function returns a reference to member fano
 * @return Reference to member fano
 */
std::map<EdgeKey, MvregEdge>& IDLNode::fano()
{
    return m_fano;
}


GraphRequest::GraphRequest()
{

}

GraphRequest::~GraphRequest()
{
}

GraphRequest::GraphRequest(
        const GraphRequest& x)
{
    m_from = x.m_from;
    m_id = x.m_id;
}

GraphRequest::GraphRequest(
        GraphRequest&& x) noexcept
{
    m_from = std::move(x.m_from);
    m_id = x.m_id;
}

GraphRequest& GraphRequest::operator =(
        const GraphRequest& x)
{

    m_from = x.m_from;
    m_id = x.m_id;
    return *this;
}

GraphRequest& GraphRequest::operator =(
        GraphRequest&& x) noexcept
{

    m_from = std::move(x.m_from);
    m_id = x.m_id;
    return *this;
}

bool GraphRequest::operator ==(
        const GraphRequest& x) const
{
    return (m_from == x.m_from &&
           m_id == x.m_id);
}

bool GraphRequest::operator !=(
        const GraphRequest& x) const
{
    return !(*this == x);
}

/*!
 * @brief This function copies the value in member from
 * @param _from New value to be copied in member from
 */
void GraphRequest::from(
        const std::string& _from)
{
    m_from = _from;
}

/*!
 * @brief This function moves the value in member from
 * @param _from New value to be moved in member from
 */
void GraphRequest::from(
        std::string&& _from)
{
    m_from = std::move(_from);
}

/*!
 * @brief This function returns a constant reference to member from
 * @return Constant reference to member from
 */
const std::string& GraphRequest::from() const
{
    return m_from;
}

/*!
 * @brief This function returns a reference to member from
 * @return Reference to member from
 */
std::string& GraphRequest::from()
{
    return m_from;
}


/*!
 * @brief This function sets a value in member id
 * @param _id New value for member id
 */
void GraphRequest::id(
        int32_t _id)
{
    m_id = _id;
}

/*!
 * @brief This function returns the value of member id
 * @return Value of member id
 */
int32_t GraphRequest::id() const
{
    return m_id;
}

/*!
 * @brief This function returns a reference to member id
 * @return Reference to member id
 */
int32_t& GraphRequest::id()
{
    return m_id;
}


DotKernel::DotKernel()
{

}

DotKernel::~DotKernel()
{
}

DotKernel::DotKernel(
        const DotKernel& x)
{
    m_ds = x.m_ds;
    m_cbase = x.m_cbase;
}

DotKernel::DotKernel(
        DotKernel&& x) noexcept
{
    m_ds = std::move(x.m_ds);
    m_cbase = std::move(x.m_cbase);
}

DotKernel& DotKernel::operator =(
        const DotKernel& x)
{

    m_ds = x.m_ds;
    m_cbase = x.m_cbase;
    return *this;
}

DotKernel& DotKernel::operator =(
        DotKernel&& x) noexcept
{

    m_ds = std::move(x.m_ds);
    m_cbase = std::move(x.m_cbase);
    return *this;
}

bool DotKernel::operator ==(
        const DotKernel& x) const
{
    return (m_ds == x.m_ds &&
           m_cbase == x.m_cbase);
}

bool DotKernel::operator !=(
        const DotKernel& x) const
{
    return !(*this == x);
}

/*!
 * @brief This function copies the value in member ds
 * @param _ds New value to be copied in member ds
 */
void DotKernel::ds(
        const std::map<PairInt, IDLNode>& _ds)
{
    m_ds = _ds;
}

/*!
 * @brief This function moves the value in member ds
 * @param _ds New value to be moved in member ds
 */
void DotKernel::ds(
        std::map<PairInt, IDLNode>&& _ds)
{
    m_ds = std::move(_ds);
}

/*!
 * @brief This function returns a constant reference to member ds
 * @return Constant reference to member ds
 */
const std::map<PairInt, IDLNode>& DotKernel::ds() const
{
    return m_ds;
}

/*!
 * @brief This function returns a reference to member ds
 * @return Reference to member ds
 */
std::map<PairInt, IDLNode>& DotKernel::ds()
{
    return m_ds;
}


/*!
 * @brief This function copies the value in member cbase
 * @param _cbase New value to be copied in member cbase
 */
void DotKernel::cbase(
        const DotContext& _cbase)
{
    m_cbase = _cbase;
}

/*!
 * @brief This function moves the value in member cbase
 * @param _cbase New value to be moved in member cbase
 */
void DotKernel::cbase(
        DotContext&& _cbase)
{
    m_cbase = std::move(_cbase);
}

/*!
 * @brief This function returns a constant reference to member cbase
 * @return Constant reference to member cbase
 */
const DotContext& DotKernel::cbase() const
{
    return m_cbase;
}

/*!
 * @brief This function returns a reference to member cbase
 * @return Reference to member cbase
 */
DotContext& DotKernel::cbase()
{
    return m_cbase;
}


MvregNode::MvregNode()
{

}

MvregNode::~MvregNode()
{
}

MvregNode::MvregNode(
        const MvregNode& x)
{
    m_id = x.m_id;
    m_dk = x.m_dk;
    m_agent_id = x.m_agent_id;
    m_timestamp = x.m_timestamp;
}

MvregNode::MvregNode(
        MvregNode&& x) noexcept
{
    m_id = x.m_id;
    m_dk = std::move(x.m_dk);
    m_agent_id = x.m_agent_id;
    m_timestamp = x.m_timestamp;
}

MvregNode& MvregNode::operator =(
        const MvregNode& x)
{

    m_id = x.m_id;
    m_dk = x.m_dk;
    m_agent_id = x.m_agent_id;
    m_timestamp = x.m_timestamp;
    return *this;
}

MvregNode& MvregNode::operator =(
        MvregNode&& x) noexcept
{

    m_id = x.m_id;
    m_dk = std::move(x.m_dk);
    m_agent_id = x.m_agent_id;
    m_timestamp = x.m_timestamp;
    return *this;
}

bool MvregNode::operator ==(
        const MvregNode& x) const
{
    return (m_id == x.m_id &&
           m_dk == x.m_dk &&
           m_agent_id == x.m_agent_id &&
           m_timestamp == x.m_timestamp);
}

bool MvregNode::operator !=(
        const MvregNode& x) const
{
    return !(*this == x);
}

/*!
 * @brief This function sets a value in member id
 * @param _id New value for member id
 */
void MvregNode::id(
        uint64_t _id)
{
    m_id = _id;
}

/*!
 * @brief This function returns the value of member id
 * @return Value of member id
 */
uint64_t MvregNode::id() const
{
    return m_id;
}

/*!
 * @brief This function returns a reference to member id
 * @return Reference to member id
 */
uint64_t& MvregNode::id()
{
    return m_id;
}


/*!
 * @brief This function copies the value in member dk
 * @param _dk New value to be copied in member dk
 */
void MvregNode::dk(
        const DotKernel& _dk)
{
    m_dk = _dk;
}

/*!
 * @brief This function moves the value in member dk
 * @param _dk New value to be moved in member dk
 */
void MvregNode::dk(
        DotKernel&& _dk)
{
    m_dk = std::move(_dk);
}

/*!
 * @brief This function returns a constant reference to member dk
 * @return Constant reference to member dk
 */
const DotKernel& MvregNode::dk() const
{
    return m_dk;
}

/*!
 * @brief This function returns a reference to member dk
 * @return Reference to member dk
 */
DotKernel& MvregNode::dk()
{
    return m_dk;
}


/*!
 * @brief This function sets a value in member agent_id
 * @param _agent_id New value for member agent_id
 */
void MvregNode::agent_id(
        uint32_t _agent_id)
{
    m_agent_id = _agent_id;
}

/*!
 * @brief This function returns the value of member agent_id
 * @return Value of member agent_id
 */
uint32_t MvregNode::agent_id() const
{
    return m_agent_id;
}

/*!
 * @brief This function returns a reference to member agent_id
 * @return Reference to member agent_id
 */
uint32_t& MvregNode::agent_id()
{
    return m_agent_id;
}


/*!
 * @brief This function sets a value in member timestamp
 * @param _timestamp New value for member timestamp
 */
void MvregNode::timestamp(
        uint64_t _timestamp)
{
    m_timestamp = _timestamp;
}

/*!
 * @brief This function returns the value of member timestamp
 * @return Value of member timestamp
 */
uint64_t MvregNode::timestamp() const
{
    return m_timestamp;
}

/*!
 * @brief This function returns a reference to member timestamp
 * @return Reference to member timestamp
 */
uint64_t& MvregNode::timestamp()
{
    return m_timestamp;
}


OrMap::OrMap()
{

}

OrMap::~OrMap()
{
}

OrMap::OrMap(
        const OrMap& x)
{
    m_to_id = x.m_to_id;
    m_id = x.m_id;
    m_m = x.m_m;
    m_cbase = x.m_cbase;
}

OrMap::OrMap(
        OrMap&& x) noexcept
{
    m_to_id = x.m_to_id;
    m_id = x.m_id;
    m_m = std::move(x.m_m);
    m_cbase = std::move(x.m_cbase);
}

OrMap& OrMap::operator =(
        const OrMap& x)
{

    m_to_id = x.m_to_id;
    m_id = x.m_id;
    m_m = x.m_m;
    m_cbase = x.m_cbase;
    return *this;
}

OrMap& OrMap::operator =(
        OrMap&& x) noexcept
{

    m_to_id = x.m_to_id;
    m_id = x.m_id;
    m_m = std::move(x.m_m);
    m_cbase = std::move(x.m_cbase);
    return *this;
}

bool OrMap::operator ==(
        const OrMap& x) const
{
    return (m_to_id == x.m_to_id &&
           m_id == x.m_id &&
           m_m == x.m_m &&
           m_cbase == x.m_cbase);
}

bool OrMap::operator !=(
        const OrMap& x) const
{
    return !(*this == x);
}

/*!
 * @brief This function sets a value in member to_id
 * @param _to_id New value for member to_id
 */
void OrMap::to_id(
        uint32_t _to_id)
{
    m_to_id = _to_id;
}

/*!
 * @brief This function returns the value of member to_id
 * @return Value of member to_id
 */
uint32_t OrMap::to_id() const
{
    return m_to_id;
}

/*!
 * @brief This function returns a reference to member to_id
 * @return Reference to member to_id
 */
uint32_t& OrMap::to_id()
{
    return m_to_id;
}


/*!
 * @brief This function sets a value in member id
 * @param _id New value for member id
 */
void OrMap::id(
        uint32_t _id)
{
    m_id = _id;
}

/*!
 * @brief This function returns the value of member id
 * @return Value of member id
 */
uint32_t OrMap::id() const
{
    return m_id;
}

/*!
 * @brief This function returns a reference to member id
 * @return Reference to member id
 */
uint32_t& OrMap::id()
{
    return m_id;
}


/*!
 * @brief This function copies the value in member m
 * @param _m New value to be copied in member m
 */
void OrMap::m(
        const std::map<uint64_t, MvregNode>& _m)
{
    m_m = _m;
}

/*!
 * @brief This function moves the value in member m
 * @param _m New value to be moved in member m
 */
void OrMap::m(
        std::map<uint64_t, MvregNode>&& _m)
{
    m_m = std::move(_m);
}

/*!
 * @brief This function returns a constant reference to member m
 * @return Constant reference to member m
 */
const std::map<uint64_t, MvregNode>& OrMap::m() const
{
    return m_m;
}

/*!
 * @brief This function returns a reference to member m
 * @return Reference to member m
 */
std::map<uint64_t, MvregNode>& OrMap::m()
{
    return m_m;
}


/*!
 * @brief This function copies the value in member cbase
 * @param _cbase New value to be copied in member cbase
 */
void OrMap::cbase(
        const DotContext& _cbase)
{
    m_cbase = _cbase;
}

/*!
 * @brief This function moves the value in member cbase
 * @param _cbase New value to be moved in member cbase
 */
void OrMap::cbase(
        DotContext&& _cbase)
{
    m_cbase = std::move(_cbase);
}

/*!
 * @brief This function returns a constant reference to member cbase
 * @return Constant reference to member cbase
 */
const DotContext& OrMap::cbase() const
{
    return m_cbase;
}

/*!
 * @brief This function returns a reference to member cbase
 * @return Reference to member cbase
 */
DotContext& OrMap::cbase()
{
    return m_cbase;
}


MvregEdgeAttrVec::MvregEdgeAttrVec()
{

}

MvregEdgeAttrVec::~MvregEdgeAttrVec()
{
}

MvregEdgeAttrVec::MvregEdgeAttrVec(
        const MvregEdgeAttrVec& x)
{
    m_vec = x.m_vec;
}

MvregEdgeAttrVec::MvregEdgeAttrVec(
        MvregEdgeAttrVec&& x) noexcept
{
    m_vec = std::move(x.m_vec);
}

MvregEdgeAttrVec& MvregEdgeAttrVec::operator =(
        const MvregEdgeAttrVec& x)
{

    m_vec = x.m_vec;
    return *this;
}

MvregEdgeAttrVec& MvregEdgeAttrVec::operator =(
        MvregEdgeAttrVec&& x) noexcept
{

    m_vec = std::move(x.m_vec);
    return *this;
}

bool MvregEdgeAttrVec::operator ==(
        const MvregEdgeAttrVec& x) const
{
    return (m_vec == x.m_vec);
}

bool MvregEdgeAttrVec::operator !=(
        const MvregEdgeAttrVec& x) const
{
    return !(*this == x);
}

/*!
 * @brief This function copies the value in member vec
 * @param _vec New value to be copied in member vec
 */
void MvregEdgeAttrVec::vec(
        const std::vector<MvregEdgeAttr>& _vec)
{
    m_vec = _vec;
}

/*!
 * @brief This function moves the value in member vec
 * @param _vec New value to be moved in member vec
 */
void MvregEdgeAttrVec::vec(
        std::vector<MvregEdgeAttr>&& _vec)
{
    m_vec = std::move(_vec);
}

/*!
 * @brief This function returns a constant reference to member vec
 * @return Constant reference to member vec
 */
const std::vector<MvregEdgeAttr>& MvregEdgeAttrVec::vec() const
{
    return m_vec;
}

/*!
 * @brief This function returns a reference to member vec
 * @return Reference to member vec
 */
std::vector<MvregEdgeAttr>& MvregEdgeAttrVec::vec()
{
    return m_vec;
}


MvregNodeAttrVec::MvregNodeAttrVec()
{

}

MvregNodeAttrVec::~MvregNodeAttrVec()
{
}

MvregNodeAttrVec::MvregNodeAttrVec(
        const MvregNodeAttrVec& x)
{
    m_vec = x.m_vec;
}

MvregNodeAttrVec::MvregNodeAttrVec(
        MvregNodeAttrVec&& x) noexcept
{
    m_vec = std::move(x.m_vec);
}

MvregNodeAttrVec& MvregNodeAttrVec::operator =(
        const MvregNodeAttrVec& x)
{

    m_vec = x.m_vec;
    return *this;
}

MvregNodeAttrVec& MvregNodeAttrVec::operator =(
        MvregNodeAttrVec&& x) noexcept
{

    m_vec = std::move(x.m_vec);
    return *this;
}

bool MvregNodeAttrVec::operator ==(
        const MvregNodeAttrVec& x) const
{
    return (m_vec == x.m_vec);
}

bool MvregNodeAttrVec::operator !=(
        const MvregNodeAttrVec& x) const
{
    return !(*this == x);
}

/*!
 * @brief This function copies the value in member vec
 * @param _vec New value to be copied in member vec
 */
void MvregNodeAttrVec::vec(
        const std::vector<MvregNodeAttr>& _vec)
{
    m_vec = _vec;
}

/*!
 * @brief This function moves the value in member vec
 * @param _vec New value to be moved in member vec
 */
void MvregNodeAttrVec::vec(
        std::vector<MvregNodeAttr>&& _vec)
{
    m_vec = std::move(_vec);
}

/*!
 * @brief This function returns a constant reference to member vec
 * @return Constant reference to member vec
 */
const std::vector<MvregNodeAttr>& MvregNodeAttrVec::vec() const
{
    return m_vec;
}

/*!
 * @brief This function returns a reference to member vec
 * @return Reference to member vec
 */
std::vector<MvregNodeAttr>& MvregNodeAttrVec::vec()
{
    return m_vec;
}

}

// Include auxiliary functions like for serializing/deserializing.
#include "IDLGraphCdrAux.ipp"
